<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
    }

    button {
      padding: 10px 20px;
      cursor: pointer;
    }

    .card {
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      margin: 10px;
      background-color: #f9f9f9;
    }

    #current-event .card {
      background-color: #e0f7fa;
    }
  </style>
</head>

<body>
  <div>
    <h1>Talia wydarze≈Ñ</h1>
    <button id="draw-card">CiƒÖgnij</button>
    <div id="current-event"></div>
    <div id="event-log"></div>
  </div>

  <script>
    const names = {
      landEventNames: ["Hidden Cove", "Abandoned Fort", "Smuggler's Den", "Treasure Cache", "Haunted Forest", "Ancient Ruins"],
      navalEventNames: ["Shipwreck", "Stormy Seas", "Pirate Ambush", "Merfolk Encounter", "Ghost Ship", "Treasure Island"],
      landFightNames: ["Battle", "Ambush", "Raid", "Skirmish", "Siege", "Invasion"],
      landEnemyNames: ["Goblin", "Orc", "Troll", "Bandit", "Wolf", "Bear", "Zombie", "Skeleton"],
      navalFightNames: ["Naval Battle", "Boarding Action", "Shipwreck", "Treasure Hunt", "Storm Encounter"],
      navalEnemyNames: ["Pirate", "Merfolk", "Kraken", "Sea Serpent", "Ghost Ship", "Nautilus", "Giant Squid"],
      explorationNames: ["Island Discovery", "Coral Reef Dive", "Underwater Ruins", "Oceanic Voyage"],
      socialInteractionNames: ["Trade", "Diplomacy", "Bargain", "Festival", "Feast", "Ritual"],
    }

    const resources = {
      epic_story: { name: "Epicka historia", cost: 6, weight: 5 },
      character: { name: "Postaƒá", cost: 4, weight: 2 },
      gold: { name: "Zo≈Çto", cost: 2, weight: 3 },
      rum: { name: "Rum", cost: 2, weight: 3 },
      spice: { name: "Przyprawa", cost: 4, weight: 3 },
    }

    class RewardsGenerator {
      constructor(points) {
        this.points = points;
        this.rewardsPool = Object.values(resources);
      }

      rewards() {
        const rewards = [];
        let remainingPoints = this.points;

        while (remainingPoints > 0) {
          const weightedPool = this.rewardsPool.filter(reward => reward.cost <= remainingPoints)
            .flatMap(reward => Array(reward.weight).fill(reward));

          if (weightedPool.length === 0) break;

          const selectedReward = weightedPool[Math.floor(Math.random() * weightedPool.length)];
          rewards.push(selectedReward.name);
          remainingPoints -= selectedReward.cost;
        }

        return rewards;
      }
    }


    class FightAction {
      constructor(type) {
        this.type = type

        this.name = this.type === "land"
          ? names.landFightNames[Math.floor(Math.random() * names.landFightNames.length)]
          : names.navalFightNames[Math.floor(Math.random() * names.navalFightNames.length)];

        this.enemies = Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () => ({
          name: this.type === "land"
            ? names.landEnemyNames[Math.floor(Math.random() * names.landEnemyNames.length)]
            : names.navalEnemyNames[Math.floor(Math.random() * names.navalEnemyNames.length)],
          health: Math.floor(Math.random() * 10) + 1,
          attack: Math.floor(Math.random() * 10) + 1
        }));

        this.rewards = new RewardsGenerator(
          (
            this.enemies.reduce((sum, enemy) => sum + enemy.attack, 0) +
            this.enemies.reduce((sum, enemy) => sum + enemy.health, 0)
          ) / 4
        ).rewards();
      }

      get icon() {
        return this.type === "land" ? "‚öîÔ∏è" : "‚õµÔ∏è";
      }

      get body() {
        return `
        <h4>${this.name}</h4>
        <h5>Wrogowie</h5> 
        ${this.enemies.map(enemy =>
          `<p>${enemy.name} (HP: ${enemy.health}, Atak: ${enemy.attack})</p>`
        ).join("")}
        <h5>Nagroda</h5> 
        <p>${this.rewards.join(", ")}</p>
        `;
      }
    }

    class ExploreAction {
      constructor(type) {
        this.name = names.explorationNames[Math.floor(Math.random() * names.explorationNames.length)];

        this.path = Array.from({ length: Math.floor(Math.random() * 19) + 2 }, () => {
          const directions = ["North", "East", "South", "West"];
          return directions.splice(Math.floor(Math.random() * directions.length), 1)[0];
        }).filter((direction, index, array) => {
          return index === 0 || direction !== array[index - 1];
        });

        this.rewards = new RewardsGenerator(
          this.path.length
        ).rewards();
      }

      get icon() {
        return "üó∫Ô∏è"
      }

      get body() {
        return `
        <h4>${this.name}</h4>
        <p>≈öcie≈ºka: ${this.path.join(", ")}</p>
        <p>Nagroda: ${this.rewards.join(", ")}</p>
        `;
      }
    }

    class SocialAction {
      constructor(type) {
        this.name = names.socialInteractionNames[Math.floor(Math.random() * names.socialInteractionNames.length)];
        this.demand = Array.from(new Set([
          resources.gold,
          Object.values(resources)[Math.floor(Math.random() * Object.values(resources).length)]
        ]));
        this.production = Object.values(resources).filter(resource => resource.name !== "Epicka historia")[Math.floor(Math.random() * (Object.values(resources).length - 1))];
      }

      get icon() {
        return "ü§ù"
      }

      get body() {

        return `
          <h4>${this.name}</h4>
          <p>Zapotrzebowanie: ${this.demand.map(d => d.name).join(", ")}</p>
          <p>Nagroda: ${this.production.name}</p>
        `;
      }
    }

    class Event {
      static probabilityWeight = 1;
      static actionClasses = [
        FightAction,
        ExploreAction,
        SocialAction
      ];

      constructor() {
        this.type = Math.random() < 0.5 ? "land" : "naval";
        this.name = this.type === "land"
          ? names.landEventNames[Math.floor(Math.random() * names.landEventNames.length)]
          : names.navalEventNames[Math.floor(Math.random() * names.navalEventNames.length)];
      }

      get actions() {
        const possibleActions = Event.actionClasses.map(ActionClass => new ActionClass(this.type));
        const randomCount = Math.floor(Math.random() * possibleActions.length) + 1;
        return possibleActions.slice(0, randomCount);
      }

      get body() {
        return `
          <div class="card">
            <h2>${this.name}</h2>
            ${this.actions.map(action => `
            <div>
              <h3>${action.icon} ${action.name}</h3>
              <div>${action.body}</div>
            </div>
            `).join('')}
          </div>
        `
      }
    }

    const generateEvents = () => {
      const events = [];
      for (let i = 0; i < 100; i++) {
        const event = new Event();
        events.push(event);
      }
      return events;
    };

    const printEvents = (events) => {
      const eventDisplay = document.getElementById("event-display");
      eventDisplay.innerHTML = events.map(event => event.body).join('');
    };


    const events = generateEvents();
    const currentEventDiv = document.getElementById("current-event");
    const eventLogDiv = document.getElementById("event-log");

    document.getElementById("draw-card").addEventListener("click", () => {
      const randomEvent = events.pop();

      if (currentEventDiv.innerHTML.trim() !== "") {
        eventLogDiv.innerHTML = currentEventDiv.innerHTML + eventLogDiv.innerHTML;
      }

      currentEventDiv.innerHTML = randomEvent.body;
    });


  </script>
</body>

</html>

</html>
