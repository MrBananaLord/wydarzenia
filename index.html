<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }

    #event-display {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <div>
    <h1>Talia wydarzeń</h1>
    <button id="draw-card">Ciągnij</button>
    <div id="event-display"></div>
  </div>

  <script>
    const names = {
      landFightNames: ["Battle", "Ambush", "Raid", "Skirmish", "Siege", "Invasion"],
      landEnemyNames: ["Goblin", "Orc", "Troll", "Bandit", "Wolf", "Bear", "Zombie", "Skeleton"],
      navalFightNames: ["Naval Battle", "Boarding Action", "Shipwreck", "Treasure Hunt", "Storm Encounter"],
      navalEnemyNames: ["Pirate", "Merfolk", "Kraken", "Sea Serpent", "Ghost Ship", "Nautilus", "Giant Squid"],
      explorationNames: ["Island Discovery", "Coral Reef Dive", "Underwater Ruins", "Oceanic Voyage"],
      socialInteractionNames: ["Trade", "Diplomacy", "Bargain", "Festival", "Feast", "Ritual"],
    }

    const resources = {
      epic_story: { name: "Epicka historia", cost: 5, weight: 1 },
      character: { name: "Postać", cost: 2, weight: 2 },
      gold: { name: "Zołto", cost: 1, weight: 3 },
      rum: { name: "Rum", cost: 1, weight: 3 },
      spice: { name: "Przyprawa", cost: 2, weight: 4 },
    }

    class RewardsGenerator {
      constructor(points) {
        this.points = points;
        this.rewardsPool = resources;
      }

      rewards() {
        const rewards = [];
        let remainingPoints = this.points;

        while (remainingPoints > 0) {
          const weightedPool = this.rewardsPool.filter(reward => reward.cost <= remainingPoints)
            .flatMap(reward => Array(reward.weight).fill(reward));

          if (weightedPool.length === 0) break;

          const selectedReward = weightedPool[Math.floor(Math.random() * weightedPool.length)];
          rewards.push(selectedReward.name);
          remainingPoints -= selectedReward.cost;
        }

        return rewards;
      }
    }


    class FightAction {
      constructor() {
        this.type = Math.random() < 0.5 ? "land" : "naval";

        this.name = this.type === "land"
          ? names.landFightNames[Math.floor(Math.random() * names.landFightNames.length)]
          : names.navalFightNames[Math.floor(Math.random() * names.navalFightNames.length)];

        this.enemies = Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () => ({
          name: this.type === "land"
            ? names.landEnemyNames[Math.floor(Math.random() * names.landEnemyNames.length)]
            : names.navalEnemyNames[Math.floor(Math.random() * names.navalEnemyNames.length)],
          health: Math.floor(Math.random() * 10) + 1,
          attack: Math.floor(Math.random() * 10) + 1
        }));

        this.rewards = new RewardsGenerator(
          this.enemies.reduce((sum, enemy) => sum + enemy.attack, 0) +
          this.enemies.reduce((sum, enemy) => sum + enemy.health, 0)
        ).rewards();
      }
    }

    class ExploreAction {
      constructor() {
        this.name = names.explorationNames[Math.floor(Math.random() * names.explorationNames.length)];

        this.path = Array.from({ length: Math.floor(Math.random() * 19) + 2 }, () => {
          const directions = ["North", "East", "South", "West"];
          return directions.splice(Math.floor(Math.random() * directions.length), 1)[0];
        }).filter((direction, index, array) => {
          return index === 0 || direction !== array[index - 1];
        });

        this.rewards = new RewardsGenerator(
          this.path.length
        ).rewards();
      }
    }

    class SocialAction {
      constructor() {
        this.name = names.socialInteractionNames[Math.floor(Math.random() * names.socialInteractionNames.length)];
        this.demand = Array.from(new Set([
          resources.gold,
          Object.values(resources)[Math.floor(Math.random() * Object.values(resources).length)]
        ]));
        this.production = Object.values(resources).filter(resource => resource.name !== "Epicka historia")[Math.floor(Math.random() * (Object.values(resources).length - 1))];
      }
    }

    class Event {
      static probabilityWeight = 1;
      static actionClasses = [
        FightAction,
        ExploreAction,
        SocialAction
      ];

      constructor(name) {
        this.name = name;
      }

      actions() {
        const possibleActions = Event.actionClasses.map(ActionClass => new ActionClass());
        const randomCount = Math.floor(Math.random() * possibleActions.length) + 1;
        return possibleActions.slice(0, randomCount);
      }
    }



  </script>
</body>

</html>

</html>
